/** Creates a w x h maze with corridors of 0 and walls of 255 expressed
    as an array of arrays using floodfill.

    If wrap is true, then the maze is on a torus. Otherwise it is on
    a rectangle.

    Imperfect is the maximum fraction of additional connections
    (creating loops). The default is zero. The maximum is 1.

    Every square is always reachable.

    Morgan McGuire
    @CasualEffects
    https://casual-effects.com

    BSD License
*/
function makeMaze(w, h, wrap, imperfect) {
    w = w || 32;
    h = h || w;
    imperfect = Math.min(1, Math.max(0, imperfect || 0));
    let random = Math.random;
    let floor = Math.floor;

    if (wrap) {
        // Ensure even size
        w += w & 1; h += h & 1;
    } else {
        // Ensure odd size
        w += ~(w & 1); h += ~(h & 1);
    }

    
    // Allocate and initialize to solid
    const SOLID = 255, EMPTY = 0;
    let maze = new Array(w);
    for (let x = 0; x < w; ++x) {
        maze[x] = new Array(h).fill(SOLID);
    }

    // Carve hallways
    let directions = [{x:-1, y:0}, {x:1, y:0}, {x:0, y:1}, {x:0, y:-1}];
    let stack = [{x:1 + floor(w / 2 - 2) * 2, y:1 + floor(h / 2 - 2) * 2, step:{x:0, y:0}}];
    while (stack.length) {
        let cur = stack.pop();

        // Unvisited?
        if (maze[cur.x][cur.y]) {
            
            // Mark visited
            maze[cur.x][cur.y] = 0;

            // Carve the wall back towards the source
            maze[(cur.x - cur.step.x + w) % w][(cur.y - cur.step.y + h) % h] = EMPTY;

            // Fisher-Yates shuffle directions
            for (let i = 3; i > 0; --i) {
                let j = floor(random() * (i + 1));
                [directions[i], directions[j]] = [directions[j], directions[i]];
            }
            
            // Push neighbors if not visited
            for (let i = 0; i < 4; ++i) {
                let step = directions[i];
                let x = cur.x + step.x * 2;
                let y = cur.y + step.y * 2;
                if (wrap) {
                    x = (x + w) % w;
                    y = (y + h) % h;
                }
                
                if ((x >= 0) && (y >= 0) && (x < w) && (y < h) && maze[x][y]) {
                    // In bounds and not visited
                    stack.push({x:x, y:y, step:step});
                }
            } // for each direction
        } // if unvisited
    } // while unvisited

    if (imperfect > 0) {
        var bdry = wrap ? 0 : 1;
        
        // Remove some random walls, preserving the edges if not wrapping.
        for (let i = Math.ceil(imperfect * w * h / 4); i > 0; --i) {
            maze[floor(random() * (w * 0.5 - bdry * 2)) * 2 + 1][floor(random() * (h * 0.5 - bdry * 2)) * 2 + bdry * 2] = EMPTY;
            maze[floor(random() * (w * 0.5 - bdry * 2)) * 2 + bdry * 2][floor(random() * (h * 0.5 - bdry * 2)) * 2 + 1] = EMPTY;
        }
        
        // Reconnect single-wall islands
        for (let y = 0; y < h; y += 2) {
            for (let x = 0; x < w; x += 2) {
                let a = maze[x][(y + 1) % h], b = maze[x][(y - 1 + h) % h],
                    c = maze[(x + 1) % w][y], d = maze[(x - 1 + w) % w][y];
                
                if (a + b + c + d === 0) {
                    // This is an island. Restore one adjacent wall at random
                    let dir = directions[floor(random() * 4)];
                    maze[(x + w + dir.x) % w][(y + h + dir.y) % h] = SOLID;
                }
            } // x
        } // y
    }

    return maze;
}


/** 
    Thickens a 2D array maze for variable width halls and walls.
    Assumes a maze generated by makeMaze in which the walls are always on even rows and
    columns. The output is no longer of that form.
*/
function mazeToMap(maze, hallWidth, wallWidth) {
    hallWidth = Math.max(1, hallWidth || 1);
    wallWidth = Math.max(1, wallWidth || 1);
    
    let width = maze.length, height = maze[0].length;

    let map = [];
    
    for (let x = 0; x < width; ++x) {
        let src = maze[x];
        for (let i = ((x & 1) ? hallWidth : wallWidth); i > 0; --i) {
            let dst = [];
            for (let y = 0; y < height; ++y) {
                let c = src[y];
                for (let j = ((y & 1) ? hallWidth : wallWidth); j > 0; --j) {
                    dst.push(c);
                } // j
            } // y
            map.push(dst);
        } // i
    } // x

    return map;
}


/** Draws 0 as empty, 255 as solid, strings as their first character, 
    and everything else as half-solid. */
function mapToString(map) {
    let width = map.length, height = map[0].length;

    let s = '';
    for (let y = 0; y < height; ++y) {
        for (let x = 0; x < width; ++x) {
            let c = map[x][y];
            s += (c === 255) ? '&#x2588;' : (c === 0) ? ' ' : c.codePointAt ? c[0] : '&#x2592;';
        }
        s += '\n';
    }
    
    return s;
}
